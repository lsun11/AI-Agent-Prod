from __future__ import annotations

import os
from pathlib import Path
from typing import Dict

from .layout_llm import DocumentLayout
from .pdf_builder import build_pdf_document
from .docx_builder import build_docx_document


def write_txt(path: str | Path, markdown: str) -> None:
    Path(path).write_text(markdown, encoding="utf-8")


def write_pdf(path: str | Path, layout: DocumentLayout) -> None:
    """
    Use your existing ReportLab logic here, but:
      - use layout.title for the title
      - use layout.report_markdown as the main content
    """
    build_pdf_document(layout.title, layout.report_markdown, str(path))


def write_docx(path: str | Path, layout: DocumentLayout) -> None:
    """
    Use your existing python-docx-based builder.
    Again, feed layout.report_markdown instead of the raw text.
    """
    build_docx_document(str(path), layout.title, layout.report_markdown)


def write_slides(path: str | Path, layout: DocumentLayout) -> None:
    """
    Create a PPTX using python-pptx and layout.slides, with a simple
    branded look:
      - Title slide uses the original query (layout.title)
      - Optional subtitle from the first slide's title (e.g. "Overall Context and Purpose")
    """
    from pptx import Presentation
    from pptx.util import Pt
    from pptx.dml.color import RGBColor

    prs = Presentation()

    title_layout = prs.slide_layouts[0]   # title slide
    bullet_layout = prs.slide_layouts[1]  # title + content

    accent_blue = RGBColor(0x13, 0x3B, 0x5C)
    text_dark = RGBColor(0x33, 0x33, 0x33)
    subtitle_gray = RGBColor(0xDD, 0xDD, 0xDD)

    # ------------------------
    # Title slide
    # ------------------------
    first = layout.slides[0] if layout.slides else None
    slide = prs.slides.add_slide(title_layout)

    # Background color
    background = slide.background
    fill = background.fill
    fill.solid()
    fill.fore_color.rgb = accent_blue

    # ðŸ”¹ Main title: always the query / overall title
    title_text = (layout.title or "").strip() or "AI Research Result"

    title_shape = slide.shapes.title
    title_shape.text = title_text
    title_tf = title_shape.text_frame
    for p in title_tf.paragraphs:
        for run in p.runs:
            run.font.size = Pt(40)
            run.font.bold = True
            run.font.color.rgb = RGBColor(0xFF, 0xFF, 0xFF)  # white

    # ðŸ”¹ Subtitle: use first-slide title if it exists, fallback to tagline
    subtitle_text = (
        first.title.strip()
        if first and getattr(first, "title", "").strip()
        else "Generated by AI Research Assistant"
    )

    if len(slide.placeholders) > 1:
        subtitle = slide.placeholders[1]
        subtitle.text = subtitle_text
        stf = subtitle.text_frame
        for p in stf.paragraphs:
            for run in p.runs:
                run.font.size = Pt(20)
                run.font.color.rgb = subtitle_gray

    # ------------------------
    # Content slides
    # ------------------------
    # We already used the first slide's title as subtitle, so start from the 2nd
    remaining_slides = layout.slides[1:] if first else layout.slides

    for slide_data in remaining_slides:
        slide = prs.slides.add_slide(bullet_layout)

        # Section title
        title_shape = slide.shapes.title
        title_shape.text = slide_data.title or ""
        ttf = title_shape.text_frame
        for p in ttf.paragraphs:
            for run in p.runs:
                run.font.size = Pt(28)
                run.font.bold = True
                run.font.color.rgb = accent_blue

        # Bullets
        body_shape = slide.placeholders[1]
        tf = body_shape.text_frame
        tf.clear()

        if slide_data.bullets:
            for i, bullet in enumerate(slide_data.bullets):
                p = tf.add_paragraph() if i > 0 else tf.paragraphs[0]
                p.text = bullet
                p.level = 0
                for run in p.runs:
                    run.font.size = Pt(18)
                    run.font.color.rgb = text_dark

    prs.save(path)




def generate_all_files_for_layout(
    layout: DocumentLayout,
    base_folder: str,
    base_filename: str,
) -> Dict[str, str]:
    """
    Given a DocumentLayout, write txt, pdf, docx, and slides,
    and return their paths.

    NOTE:
    - TXT / PDF / DOCX are always written to project-root "saved_docs/"
    - PPTX is always written to project-root "saved_slides/"
    - `base_folder` is kept for backwards compatibility but ignored
      for the final locations, so that /download/{filename} can
      reliably look in saved_docs/ and saved_slides/.
    """
    docs_dir = Path("saved_docs")
    slides_dir = Path("saved_slides")

    docs_dir.mkdir(parents=True, exist_ok=True)
    slides_dir.mkdir(parents=True, exist_ok=True)

    # Base names (same filename across all formats)
    base_docs = docs_dir / base_filename
    base_slides = slides_dir / base_filename

    txt_path = base_docs.with_suffix(".txt")
    pdf_path = base_docs.with_suffix(".pdf")
    docx_path = base_docs.with_suffix(".docx")
    pptx_path = base_slides.with_suffix(".pptx")

    # Actually write files
    write_txt(txt_path, layout.report_markdown)
    write_pdf(pdf_path, layout)
    write_docx(docx_path, layout)
    write_slides(pptx_path, layout)

    return {
        "txt": str(txt_path),
        "pdf": str(pdf_path),
        "docx": str(docx_path),
        "pptx": str(pptx_path),
    }
